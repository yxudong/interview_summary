#### HTTP 支持的方法

| 方法名 | 说明 | 支持的 HTTP 协议版本 | 详细说明|
| :---: | :---: | :---: |:---: |
| GET | 获取资源 | 1.0、1.1 | GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。（我想访问你的某个资源）|
| POST | 传输实体主体 | 1.0、1.1 | POST 方法用来传输实体的主体。虽然 GET 也可以传输实体的主体，但一般不用 GET 而用 POST，POST 的主要目的并不是获取响应的主体内容。（我想把这条信息告诉你）|
| PUT | 传输文件 | 1.0、1.1 | 要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定位置。（我想要把这份文件传给你）|
| HEAD | 获取报文首部 | 1.0、1.1 | HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等等（我想要那个相关信息）|
| DELETE | 删除文件 | 1.0、1.1 | 与 PUT 相反的方法，DELETE 方法按请求 URI 删除指定资源（把这份文件删掉吧）|
| OPTIONS | 询问支持的方法 | 1.1 | OPTIONS 用来查询针对请求 URI 指定的资源支持的方法（你支持哪些方法？）|
| TRACE | 追踪路径 | 1.1 | TRACE 方法是让 Web 服务器将之前的请求通信返回给客户端的方法，TRACE 方法不常用，并且容易引发 XST ( Cross-Site-Tracing ，跨站追踪)攻击，所以通常更不会用到了|
| CONNECT | 要求用隧道协议连接代理 | 1.1 | CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信，主要使用 SSL （ Secure Sockets Layers ，安全套接层）和 TLS （ Transport Layer Security ，传输层安全）协议把通信内容加密后经网络隧道传输|
| PATCH | 更新部分文件内容| 1.1| **当资源存在的时候**，PATCH 用于资源的部分内容的更新，例如更新某一个字段。具体比如说只更新用户信息的电话号码字段，而 PUT 用于更新某个资源较完整的内容，比如说用户要重填完整表单更新所有信息，后台处理更新时可能只是保留内部记录 ID 不变。<br>**当资源不存在的时候**，PATCH 是修改原来的内容，也可能会产生一个新的版本。比如当资源不存在的时候，PATCH 可能会去创建一个新的资源，这个意义上像是 saveOrUpdate 操作。而 PUT 只对已有资源进行更新操作，所以是 update 操作|
| LINK | 建立和资源之间的联系 | 1.0 | ✖︎最新版中已经废弃✖︎|
| UNLINK | 断开连接关系 | 1.0 | ✖︎最新版中已经废弃✖︎|

#### HTTP 方法的幂等和安全性

    HTTP 方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。

    HTTP 方法的安全性指的是不会改变服务器状态，也就是说它只是可读的。所以只有 OPTIONS、GET、HEAD 是安全的，其他都是不安全的。

| HTTP 方法 | 幂等性 | 安全性 |
| :---: | :---: | :---: |
|OPTIONS|	yes	|yes|
|GET	|yes	|yes|
|HEAD	|yes	|yes|
|PUT	|yes	|no|
|DELETE	|yes	|no|
|POST	|no	|no|
|PATCH	|no	|no|

    **POST 和 PATCH 这两个不是幂等性的**。
    两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI。
    对同一URI进行多次PUT的副作用和一次PUT是相同的。

#### HTTP 状态码

| 状态码 | 类别 | 原因短语 |
| :---: | :---: | :---: |
| 1XX | Informational（信息性状态码） | 接收的请求正在处理 |
| 2XX | Success（成功状态码） | 请求正常处理完毕 |
| 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |

    ##### 1XX 信息

    -  **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

    ##### 2XX 成功

    -  **200 OK** 
    -  **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
    -  **206 Partial Content** ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。

    ##### 3XX 重定向

    -  **301 Moved Permanently** ：永久性重定向
    -  **302 Found** ：临时性重定向
    -  **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
    - 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
    -  **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
    -  **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

    ##### 4XX 客户端错误

    -  **400 Bad Request** ：请求报文中存在语法错误。
    -  **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
    -  **403 Forbidden** ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。
    -  **404 Not Found**
    -  **405 Method Not Allowed：不允许使用的方法，请求中有一个所请求的 URI 不支持的方法。响应中应该包含一个 Allow 首部，以告知客户端所请求的资源支持使用哪些方法| 

    ##### 5XX 服务器错误

    -  **500 Internal Server Error** ：服务器正在执行请求时发生错误。
    -  **503 Service Unavilable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

#### HTTP 报文结构

<p align='center'>
<img src='../images/请求报文.png'>
</p>


<p align='center'>
<img src='../images/响应报文.png'>
</p>

<p align='center'>
<img src='../images/报文实例.png'>
</p>

#### HTTP 并行连接、持久连接、管道化连接

    1. 并行连接
       通过多条 TCP 连接发起并发的 HTTP 请求。
    2. 持久连接
       重用 TCP 连接，以消除连接及关闭的时延。 持久连接（HTTP Persistent Connections），也称为 HTTP keep-alive 或者 HTTP connection reuse 。
       在 HTTP/1.1 中，所有的连接默认都是持久连接。要求服务端，客户端都支持持久连接。
    3. 管道化连接 
       通过共享的 TCP 连接发起并发的 HTTP 请求。
       持久连接使得多数请求以管线化（pipelining）方式发送成为可能。以前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应，直接发送下一个请求。
       比如当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。
       因为实现比较复杂，而且会带来线头阻塞问题（若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞），所以真正用的并不多。

#### HTTP/1.0 与 HTTP/1.1 的区别

    1. HTTP/1.1 默认是持久连接
    2. HTTP/1.1 支持管线化处理
    3. HTTP/1.1 支持虚拟主机
    4. HTTP/1.1 新增了状态码
    5. HTTP/1.1 支持分块传输编码
    6. HTTP/1.1 新增缓存处理指令 max-age

#### HTTP/1.0 与 HTTP/1.1 的区别

    1. HTTP/1.1 默认是持久连接
    2. HTTP/1.1 支持管线化处理
    3. HTTP/1.1 支持虚拟主机
    4. HTTP/1.1 新增了状态码
    5. HTTP/1.1 支持分块传输编码
    6. HTTP/1.1 新增缓存处理指令 max-age

#### HTTP/1.1 与 HTTP/2.0 的区别

    1. 二进制分帧
        HTTP/2.0 在应用层（HTTP/2）和传输层（TCP or UDP）之间增加一个二进制分帧层。
        在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下，解决了 HTTP/1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。
        在二进制分帧层中，HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码。
        其中 HTTP/1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。
    2. 多路复用
       HTTP/2.0 使用多路复用技术，同一个 TCP 连接可以处理多个请求。通过给每个帧带上标签的问题解决了线头阻塞。
    3. 首部压缩
        HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 对首部进行压缩，要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。
    4. 服务端推送
        HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 index.html 页面，服务端就把 index.js 一起发给客户端。
    5. 二进制格式
        HTTP/1.1 的解析是基于文本的，而 HTTP/2.0 采用二进制格式。

#### HTTP/2.0 vs SPDY

    HTTP/2.0 是 SPDY 的升级版（基于SPDY设计），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：
        1. HTTP/2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
        2. HTTP/2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE

#### HTTP/3

    HTTP/3 基于 QUIC 协议实现
    1. HTTP/2.0 虽然解决了线头阻塞的问题，但是 TCP 协议本身就存在阻塞问题，比如某个包丢失，后面的包要等待确认重传，所以 HTTP/3 改为使用 UDP 协议。
    2. 关于拥塞控制，TCP 是在内核区实现的，而 HTTP3 将拥塞控制移出了内核，通过用户空间来实现。这样做的好处就是不再需要等待内核更新可以实现很方便的进行快速迭代。
    3. HTTPS 使用的 TLS 协议也存在队头阻塞问题。QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题；

dns 递归查询和递归查询
dns劫持
dns污染
http dns
ipv6 和 ipv4 区别
HTTP劫持
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
























