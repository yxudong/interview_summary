# 进程和线程的区别

    1. 拥有资源
        进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问同一进程的资源
    2. 调度
        线程是独立调度的基本单位，同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程内的线程会引起进程切换
    3. 系统开销
        创建和撤销进程时，系统都要为之分配或回收资源，所付出的开销远大于创建或撤销线程时的开销。
        同样的在进程切换时，也会涉及当前执行进程 CPU 环境的保存以及新调度进程 CPU 环境的设置，
        而线程的切换只需保存和设置少量寄存器的内容，开销很小
    4. 通信方面
        进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性。
        而线程间可以通过直接读/写同意进程中的数据段（如全局变量）来进行通信。

# 进程间通信方式

    参考：
        1. [凉了！张三同学没答好「进程间通信」，被面试官挂了....](https://www.cnblogs.com/xiaolincoding/p/13402297.html)
        2. [远程服务调用](https://icyfenix.cn/architect-perspective/general-architecture/api-style/rpc.html)

    1. 管道（Pipe）或者具名管道（Named Pipe）
        管道类似于两个进程间的桥梁，可通过管道在进程间传递少量的字符流或字节流。
        普通管道只用于有亲缘关系进程（由一个进程启动的另外一个进程）间的通信，
        具名管道摆脱了普通管道没有名字的限制，除具有管道所有的功能外，它还允许无亲缘关系进程间的通信。
        管道典型的应用就是命令行中的|操作符，譬如：
        ```
        ps -ef | grep java
        ```
        ps 与 grep 都有独立的进程，以上命令就通过管道操作符 | 将 ps 命令的标准输出连接到 grep 命令的标准输入上。
        所谓的管道，就是内核里面的一串缓存，遵循先进先出原则，不支持 lseek 之类的文件定位操作。
        管道这种通信方式效率低，不适合进程间频繁地交换数据。
        当然，它的好处，自然就是简单，同时也很容易得知管道里的数据已经被另一个进程读取了。

    2. 消息队列
        消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），
        如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。
        消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，
        而匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。

        不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，
        同时在消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。

    3. 共享内存
        共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。
        不会发生用户态与内核态之间的消息拷贝过程，这是效率最高的进程间通信形式。
        原本每个进程的内存地址空间都是相互隔离的，但操作系统提供了让进程主动创建、映射、分离、控制某一块内存的程序接口。
        当一块内存被多进程共享时，各个进程往往会与其它通信机制，譬如信号量结合使用，来达到进程间同步及互斥的协调操作。

<p align='center'>
    <img src='./images/操作系统/共享内存.png'>
</p>

    4. 信号量
        信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。
        P 操作会把信号量减去 -1，V 操作会把信号量加上 1，
        P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。

    5. 信号
        信号用于通知目标进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程自身。
        信号的典型应用是 kill 命令，例如：
        ```
        kill -9 pid
        ```
        以上就是由 Shell 进程向指定 PID 的进程发送 SIGKILL 信号。

    6. Socket
        管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，
        要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信。
        Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。

# 进程同一个主机通信和不同主机通信有什么区别？

    同一个主机通信可以有多种方式，包括管道、消息队列、共享内存、信号量和信号和 Socket。
    不同主机通信只能通过 Socket。

# 多进程和多线程的区别

<p align='center'>
    <img src='./images/操作系统/多进程和多线程的区别.png'>
</p>

# 进程切换和线程切换

    参考：
        1. [进程切换和线程切换？](https://www.cnblogs.com/lfri/p/12597297.html)

    进程切换：
        1.切换页目录以使用新的地址空间
        2.切换内核栈和硬件上下文。

    线程切换：
        切换内核栈和硬件上下文。

    进程切换与线程切换的区别：
        最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。
        因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，
        因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

# 进程的基本状态

    创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态

就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行

执行状态：进程处于就绪状态被调度后，进程进入执行状态

阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用

终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行

# 线程的几种状态

    todo

# 如何理解互斥锁、条件锁、读写锁以及自旋锁

    todo
    https://www.zhihu.com/question/66733477?sort=created

# 死锁

    todo

# 什么是内存抖动

    todo

# 操作系统中进程调度策略有哪几种？

    todo

# 什么叫僵尸进程？怎么处理僵尸进程？

    todo

# 页面置换算法

    todo

# 软链接和硬连接的区别

    todo

# 虚拟内存与物理内存

    todo
    参考：
        1. [虚拟内存与物理内存的联系与区别](https://blog.csdn.net/lvyibin890/article/details/82217193)

    操作系统有虚拟内存与物理内存的概念。在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：

    因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的
    由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的
    因为内存时随机分配的，所以程序运行的地址也是不正确的。
    于是针对上面会出现的各种问题，虚拟内存就出来了。

    在之前一篇文章中进程分配资源介绍过一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都认为自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的一点点的物理内存，实际用了多少内存，就会对应多少物理内存。

    进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。

    进程开始要访问一个地址，它可能会经历下面的过程

    每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
    所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
    进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
    页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
    当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
    缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。




















