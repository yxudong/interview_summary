# 进程和线程的区别

    1. 拥有资源
        进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问同一进程的资源
    2. 调度
        线程是独立调度的基本单位，同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程内的线程会引起进程切换
    3. 系统开销
        创建和撤销进程时，系统都要为之分配或回收资源，所付出的开销远大于创建或撤销线程时的开销。
        同样的在进程切换时，也会涉及当前执行进程 CPU 环境的保存以及新调度进程 CPU 环境的设置，
        而线程的切换只需保存和设置少量寄存器的内容，开销很小
    4. 通信方面
        进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性。
        而线程间可以通过直接读/写同意进程中的数据段（如全局变量）来进行通信。

# 进程间通信方式

    参考：
        1. [凉了！张三同学没答好「进程间通信」，被面试官挂了....](https://www.cnblogs.com/xiaolincoding/p/13402297.html)
        2. [远程服务调用](https://icyfenix.cn/architect-perspective/general-architecture/api-style/rpc.html)

    1. 管道（Pipe）或者具名管道（Named Pipe）
        管道类似于两个进程间的桥梁，可通过管道在进程间传递少量的字符流或字节流。
        普通管道只用于有亲缘关系进程（由一个进程启动的另外一个进程）间的通信，
        具名管道摆脱了普通管道没有名字的限制，除具有管道所有的功能外，它还允许无亲缘关系进程间的通信。
        管道典型的应用就是命令行中的|操作符，譬如：
        ```
        ps -ef | grep java
        ```
        ps 与 grep 都有独立的进程，以上命令就通过管道操作符 | 将 ps 命令的标准输出连接到 grep 命令的标准输入上。
        所谓的管道，就是内核里面的一串缓存，遵循先进先出原则，不支持 lseek 之类的文件定位操作。
        管道这种通信方式效率低，不适合进程间频繁地交换数据。
        当然，它的好处，自然就是简单，同时也很容易得知管道里的数据已经被另一个进程读取了。

    2. 消息队列
        消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），
        如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。
        消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，
        而匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。

        不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，
        同时在消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。

    3. 共享内存
        共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。
        不会发生用户态与内核态之间的消息拷贝过程，这是效率最高的进程间通信形式。
        原本每个进程的内存地址空间都是相互隔离的，但操作系统提供了让进程主动创建、映射、分离、控制某一块内存的程序接口。
        当一块内存被多进程共享时，各个进程往往会与其它通信机制，譬如信号量结合使用，来达到进程间同步及互斥的协调操作。

<p align='center'>
    <img src='./images/操作系统/共享内存.png'>
</p>

    4. 信号量
        信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。
        P 操作会把信号量减去 -1，V 操作会把信号量加上 1，
        P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。

    5. 信号
        信号用于通知目标进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程自身。
        信号的典型应用是 kill 命令，例如：
        ```
        kill -9 pid
        ```
        以上就是由 Shell 进程向指定 PID 的进程发送 SIGKILL 信号。

    6. Socket
        管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，
        要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信。
        Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。

# 进程同一个主机通信和不同主机通信有什么区别？

    同一个主机通信可以有多种方式，包括管道、消息队列、共享内存、信号量和信号和 Socket。
    不同主机通信只能通过 Socket。

# 多进程和多线程的区别

<p align='center'>
    <img src='./images/操作系统/多进程和多线程的区别.png'>
</p>

# 进程切换和线程切换

    参考：
        1. [进程切换和线程切换？](https://www.cnblogs.com/lfri/p/12597297.html)

    进程切换：
        1.切换页目录以使用新的地址空间
        2.切换内核栈和硬件上下文。

    线程切换：
        切换内核栈和硬件上下文。

    进程切换与线程切换的区别：
        最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。
        因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，
        因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

# 进程的基本状态

<p align='center'>
    <img src='./images/操作系统/进程状态切换图.png'>
</p>

    运行态，运行态指的就是进程实际占用 CPU 时间片运行时。
    就绪态，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态。
    阻塞态，除非某种外部事件发生，否则进程不能运行。

# 什么叫僵尸进程和孤儿进程？怎么处理僵尸进程？

    参考：
        1. [僵尸进程和僵死进程有什么区别? - wuxinliulei的回答 - 知乎](https://www.zhihu.com/question/26432067/answer/70643183)
        2. [孤儿进程与僵尸进程[总结]](https://www.cnblogs.com/anker/p/3271773.html)

    孤儿进程：
        一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。
        孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

　　僵尸进程：
        一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，
        那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

    怎么处理僵尸进程：
        1. 通过 Kill 杀掉父进程
        2. fork 两次，原理是将子进程成为孤儿进程，从而其的父进程变为 init 进程，通过 init 进程可以处理僵尸进程。

# 操作系统中进程调度策略有哪几种？

    Linux 把进程区分为实时进程和非实时进程，其中非实时进程进一步划分为交互式进程和批处理进程。

<p align='center'>
    <img src='./images/操作系统/进程的分类.png'>
</p>

    在 Linux 中，调度算法可以明确的确认所有实时进程的身份，但是没办法区分交互式程序和批处理程序，
    Linux2.6 的调度程序实现了基于进程过去行为的启发式算法，以确定进程应该被当做交互式进程还是批处理进程。
    当然与批处理进程相比，调度程序有偏爱交互式进程的倾向。
    
    批处理中的调度：
        先来先服务
        最短作业优先
        最短剩余时间优先
        高响应比优先调度算法
    交互式系统中的调度：
        时间片轮询调度
        优先级调度
        多级队列：
            每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。
            每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。
    实时调度：
        FIFO 或者 Round Robin

# 什么是内存抖动

    内存抖动是指在短时间内有大量的对象被创建或者被回收的现象，主要是循环中大量创建、回收对象。这种情况应当尽量避免。

# 什么是页面抖动

    在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，
    这种频繁的页面调度行为称为抖动，或颠簸。

# 页面置换算法

    参考：
        1. [页面置换算法](https://zhuanlan.zhihu.com/p/47814764)
        2. [操作系统学习(10)页面置换算法](操作系统学习(10)页面置换算法)

    先进先出（FIFO）
        有 belady 现象（给的物理页帧越多反而缺页越频繁）。
    最近最少使用（LRU）
        比较优秀，但是很难实现。
    时钟（CLOCK）置换算法
        简单的 CLOCK 算法是给每一帧关联一个附加位，称为使用位。
        又称为最近未用（Not Recently Used, NRU）算法。
    改进型的 clock 算法
        在使用位的基础上再增加一个修改位，则得到改进型的 CLOCK 置换算法。
    LFU（least frequently used，最不常用算法）
    MFU（最常使用算法）

    MFU 和 LFU 置换都不常用。这些算法的实现是昂贵的，并且它们不能很好地近似 OPT（理想中的最佳置换算法） 置换。

# 虚拟内存与物理内存

    todo
    参考：
        1. [虚拟内存与物理内存的联系与区别](https://blog.csdn.net/lvyibin890/article/details/82217193)

    操作系统有虚拟内存与物理内存的概念。在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：

    因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的
    由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的
    因为内存时随机分配的，所以程序运行的地址也是不正确的。
    于是针对上面会出现的各种问题，虚拟内存就出来了。

    在之前一篇文章中进程分配资源介绍过一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都认为自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的一点点的物理内存，实际用了多少内存，就会对应多少物理内存。

    进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。

    进程开始要访问一个地址，它可能会经历下面的过程

    每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
    所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
    进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
    页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
    当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
    缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。

# 软链接和硬连接的区别

    硬链接：
        硬链接是指针，所有的硬链接都是指向同一个磁盘块。
        删除一个指针不会真正删除文件，只有把所有的指针都删除才会真正删除文件。
    软连接：
        软连接是另外一种类型的文件，保存的是它指向文件的全路径，访问时会替换成绝对路径。
        删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身，这一点类似于 Windows 操作系统下的快捷方式。

# 如何理解互斥锁、条件锁、读写锁以及自旋锁

    todo
    https://www.zhihu.com/question/66733477?sort=created

# 死锁

    todo

# Linux 文件权限和类型

<p align='center'>
    <img src='./images/操作系统/Linux 文件权限.png'>
</p>

# Linux 文件类型有哪些

<p align='center'>
    <img src='./images/操作系统/Linux 文件类型.png'>
</p>

    占用存储空间的类型：文件、目录、符号链接。符号链接记录的是路径，路径不长时存在innode里面。

    其他四种：套接字、块设备、字符设备、管道是伪文件，不占用磁盘空间。

# epoll

    todo
