
	
### 7、__init__, __new__ 区别
	1.首先用法不同
　　 	new()用于创建实例，所以该方法是在实例创建之前被调用，它是类级别的方法，是个静态方法；
		init() 用于初始化实例，所以该方法是在实例对象创建后被调用，它是实例级别的方法，用于设置对象属性的一些初始值。
		由此可知，new()在__init__() 之前被调用。如果__new__() 创建的是当前类的实例，会自动调用__init__()函数，通过return调用的__new__()的参数cls来保证是当前类实例，如果是其他类的类名，那么创建返回的是其他类实例，就不会调用当前类的__init__()函数。
	2.其次传入参数不同:
　　		new()至少有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别；
		init()至少有一个参数self，就是这个__new__()返回的实例，init()在__new__()的基础上完成一些初始化的操作。
	3.返回值不同:
　　		new()必须有返回值，返回实例对象；
		init()不需要返回值。
### 9、Python 垃圾回收机制

	#引用计数机制：
	Python内部使用了一个PyObject结构体来保存全部对象共同的数据成员，以及实现GC机制所须要的一些辅助字段等．所以能够说PyObject就是Python对象机制的基石。
	引用计算是对每一个对象维护一个引用计数器ob_ref,记录对象被引用多少次，当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁
	ob_ref加1的情况：
					1、对象被创建
					2、被引用
					3、被作为参数
					4、作为一个元素存在容器中
	ob_ref减1的情况：
					1、当该对象的别名被显式销毁时： del a
					2、当该对象的引别名被赋予新的对象： a=26
					3、一个对象离开它的作用域：例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
					4、将该元素从容器中删除时，或者容器被销毁时。
	优点：
		1、高效
		2、实时性：一旦没有引用，内存就被释放掉
		3、对象有确定的生命周期
		4、易于实现
	缺点：
		1、维护引用计数消耗资源
		2、无法解决循环引用的情况：A、B相互引用但是都未被其他对象引用时应该被回收资源
		
	#2、标记-清除
	目的：是为了解决循环引用，『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。
	它分为两个阶段：
		第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，
		第二阶段是把那些没有标记的对象『非活动对象』进行回收。
	那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？
		对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。
		从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，
		不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。	
	处理对象：一般是容器对象：list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。
	缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。
	总结：
		“标记-清除”法是为了解决循环引用问题。可以包含其他对象引用的容器对象（如list, dict, set，甚至class）都可能产生循环引用，
		为此，在申请内存时，所有容器对象的头部又加上了PyGC_Head来实现“标记-清除”机制。
		任何一个python对象都分为两部分: PyObject_HEAD + 对象本身数据
	#3、分代回收	
	原理:
		分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，
		Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），
		他们对应的是3个链表，它们的垃圾收集频率随着对象存活时间的增大而减小。
	如何分代：
		1、一开始，对象在创建的时候，放在一代中，
		2、如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，
		3、同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。
	处理对象：分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象
	#三种情况会触发垃圾回收：
	1、调用gc.collect(),需要先导入gc模块。
		gc模块提供一个接口给开发者设置垃圾回收的选项。gc模块的一个主要功能就是解决循环引用的问题。
		常用函数：
			gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK
			gc.collect([generation])显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。返回不可达（unreachable objects）对象的数目。
			gc.set_threshold(threshold0[, threshold1[, threshold2])设置自动执行垃圾回收的频率。
			gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表
	2、当gc模块的计数器达到阈值的时候。
		每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器
	3、程序退出的时候。

### 11、yield 关键字作用
	定义：
		如果一个对象包含iter或者getitem方法，则该对象是可迭代的，迭代器是一个对象，只允许迭代一次，
		对迭代器调用next方法会返回下一个容器元素，迭代器调用iter方法返回的是迭代器本身，含有yield关键字的函数
		是一个生成器函数，生成器是一种特殊的迭代器。
	使用：
		当生成器函数被调用时，内部代码不会立刻执行，只有调用成员的时候才会执行；
		每次执行到 x = geniter.next() 时，square 函数会从上一次暂停的位置开始，
		一直执行到下一个 yield 表达式，将 yield 关键字后的表达式列表返回给调用者，并再次暂停。
		注意，每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致。
	作用：
		内建函数 range 和 xrange。其中，range 函数返回的是一个列表，而 xrange 返回的是一个迭代器。
		在 Python 3 中，range 相当于 Python 2 中的 xrange；而 Python 2 中的 range 可以用 list(range()) 来实现。
		Python 之所以要提供这样的解决方案，是因为在很多时候，我们只是需要逐个顺序访问容器内的元素。
		大多数时候，我们不需要「一口气获取容器内所有的元素」
	1、将一个函数修改为生成器，利用生成器可以有效地节约系统资源，避免不必要的内存占用；
	2、用于定义上下文管理器；
	3、协程；
	4、配合from形成yield from用于消费子生成器并传递消息。
	
### 12、await 和 async 等关键字，版本，作用
	协程与线程：
		协程与线程相似的地方是多个线程之间也可以交替执行，不过与线程不同之处在于协程之间的切换是显式的，而线程是隐式的（大多数情况下是更好的方式）。所以我们需要加入显式切换的代码。
	
### 13、tornado 实现原理
https://www.jiqizhixin.com/articles/2019-04-10-15

### 14、可变对象和不可变对象
	不可变对象 ：int，string，float，tuple   -- 可理解为C中，该参数为值传递
	可变对象   ：list，dictionary           -- 可理解为C中，该参数为指针传递
	由于 Python 中的变量存放的是对象引用，所以对于不可变对象而言，尽管对象本身不可变，但变量的对象引用是可变的。
	A=1中A是对象的引用，1是int对象，不可变对象
### 15、GIL
	https://zhuanlan.zhihu.com/p/20953544
	1、GIL是什么？GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。
	2、每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）
  # 在Python多线程下，每个线程的执行方式：
	1.获取GIL
	2.执行代码直到sleep或者是python虚拟机将其挂起。
	3.释放GIL
	可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。
	在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。
	而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。
	  #那么是不是python的多线程就完全没用了呢？
	分类讨论：
	1、CPU密集型代码(各种循环处理、计数等等)，在这种情况下，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。
	2、IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。
	而在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。
	多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低
	 # 经常我们会听到老手说：“python下想要充分利用多核CPU，就用多进程”，原因是什么呢？
	原因是：每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。
	所以我们能够得出结论：多核下，想做并行提升效率，比较通用的方法是使用多进程，能够有效提高执行效率

### 17、super 作用

python中允许多继承，但是多继承的公共父类在执行的时候会执行多次，使用super()机制就可以让公共父类只执行一次，执行顺序是按照MRO来执行的。
一个类的 MRO 列表就是合并所有父类的 MRO 列表，并遵循以下三条原则：
	1、子类永远在父类前面
	2、如果有多个父类，会根据它们在列表中的顺序被检查
	3、如果对下一个类存在两个合法的选择，选择第一个父类
	
super 原理
super 的工作原理如下：
```
def super(cls, inst):
    mro = inst.__class__.mro()
    return mro[mro.index(cls) + 1]
```
其中，cls 代表类，inst 代表实例，上面的代码做了两件事：
获取 inst 的 MRO 列表
查找 cls 在当前 MRO 列表中的 index, 并返回它的下一个类，即 mro[index + 1]
当你使用 super(cls, inst) 时，Python 会在 inst 的 MRO 列表上搜索 cls 的下一个类。

使用：
Python3.x 和 Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx 

### 20、property 作用

Python内置的@property装饰器作用：
1. 就是负责把一个方法变成属性调用的
2. property可以设置可读可写属性，设置可读属性可以防止数据被修改
```
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2014 - self._birth
```
如上，birth是可读写属性，age是可读属性

### 22、slots 作用
	__slots__是用来声明实例的属性，普通的声明方法是__dict__
	与__dict__相比,__solts__的优点如下：
	1、更快的属性访问速度
		dict访问需要4步：a.x > a.__dict__ > a.__dict__[x] > 获得结果
		slots访问需要3步：a.x > member decriptor > 结果
	2、减少内存消耗
		dict是个哈希表，它是一种以空间换时间的数据结果，为了解决冲突，python会在字典使用量超过2/3时，会进行2-4倍的扩容
		slots使用了描述符，只会为属性存储分配必要的内存，所以能够大幅减少内存的使用。
	#slots的实现原理
  ''' slot的创建没懂

	#slots的继承：
	1、父类有、子类没有：子类的实例还是会自动创建__dict__来存储属性，不过父类__slots__已有的属性不受影响。
	2、父类没有、子类有：虽然子类取消了__dict__，但继承父类后它会继续生成。同上面一样，__slots__已有的属性不受影响。
	3、父类有，子类有：只有子类的__slots__有效，访问父类有子类没有的属性依然会报错。
	4、多个拥有非空slots的父类：由于__slots__的实现不是简单的列表或字典，多个父类的非空__slots__不能直接合并，所以使用时会报错（即使多个父类的非空__slots__是相同的）。
	5、多个空slots的父类：这是关于slots使用多继承唯一办法
	6、某些父类有，某些父类没有：跟第一种情况类似。
	#slots的缺点：
	用在普通类身上时，使用__slots__后会丧失动态添加属性和弱引用（添加__weakref__可以获取弱引用功能）的功能，进而引起其他错误，所以在一般情况下不要使用它。
	
	

### 23、介绍一下Python 锁？

### 24、什么是python的生成器?

生成器是支持在循环过程中计算推出后续元素的机制
生成器生成方式有两种:
1. 列表生成式的[]改成（）
2. 函数中使用yield返回

优点：
生成器解决了列表访问元素的内存限制问题，不是一次把所有元素读入，而是存表达式，需要的时候计算出元素的值
原理：
在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。
调用一个生成器函数，返回的是一个迭代器对象。

### 25、装饰器的写法以及应用场景。

https://www.cnblogs.com/xxpythonxx/p/12104424.html
https://www.cnblogs.com/superhin/p/11454823.html

### 26、什么是反射？以及应用场景？
https://www.jianshu.com/p/628f61f01a54
1. 定义：
反射是通过字符串映射object对象的方法或者属性
具体做法如下：
1、输入字符串
2、通过hasattr(commons,inp)判断是否有与字符串同名的函数
3、通过getattr(commons,inp)获得同名函数
通过hasattr的判断，可以防止非法输入错误，并将其统一定位到错误页面。
其实，研究过python内置函数的朋友，应该注意到还有delattr和setattr两个内置函数。从字面上已经很好理解他们的作用了。
python的四个重要内置函数：getattr、hasattr、delattr和setattr较为全面的实现了基于字符串的反射机制。他们都是对内存内的模块进行操作，并不会对源文件进行修改。

应用场景：
在我们做接口自动化的时候,需要通过不同的请求方式,调用不同的函数


### 30、 *arg和**kwarg作用

如果我们不确定要往函数中传入多少个参数，或者我们想往函数中以列表和元组的形式传参数时，那就使要用*args；
如果我们不知道要往函数中传入多少个关键词参数，或者想传入字典的值作为关键词参数时，那就要使用**kwargs；
*args用来将参数打包成tuple（元组）给函数体调用
**kwargs 打包关键字参数成dict（字典）给函数体调用

### 35、Python 装饰器的原理
https://www.cnblogs.com/liyasen/p/6477817.html






















