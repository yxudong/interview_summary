**1. slice 的底层实现**

	切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。
	```
	type slice struct {
		array unsafe.Pointer
		len   int
		cap   int
	}
	```
	切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。

**2. 切片扩容策略**

	Go 中切片扩容的策略是这样的：

	1. 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）
	2. 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）
	3. 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap >= cap）
	4. 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）

	注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。

**3. 切片扩容后是新数组 or 老数组 ？**

	1. 由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。
	2. 如果原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。

**4. Go 的垃圾回收机制**

		* Go V1.3之前标记-清除(mark and sweep)算法
		* Go V1.5的三色并发标记法
		* Go V1.8混合写屏障机制

    当前Golang使用的垃圾回收机制是三色标记发配合写屏障和辅助GC，三色标记法是标记-清除法的一种增强版本。

	标记-清除法需要程序暂停，即 STW(stop the world)
	三色并发需要遵循三色不变性，屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术

	垃圾回收中的写屏障可以理解为编译器在写操作时特意插入的一段代码，对应的还有读屏障。
	因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。

	为什么需要写屏障，很简单，对于和用户程序并发运行的垃圾回收算法，用户程序会一直修改内存，所以需要记录下来。

	Golang 1.7 之前的写屏障使用的经典的 Dijkstra-style insertion write barrier， STW 的主要耗时就在 stack re-scan 的过程。
	自 1.8 之后采用一种混合的写屏障方式 （Yuasa-style deletion write barrier 和 Dijkstra-style insertion write barrier）来避免 re-scan
